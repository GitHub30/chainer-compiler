import argparse
import os
import sys


project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(os.path.join(project_root, 'common'))
sys.path.append(os.path.join(project_root, 'runtime'))
import codegen_util
from xcvm_defs import *


parser = argparse.ArgumentParser()
parser.add_argument("--output-dir", required=True, help="")
args = parser.parse_args()


def make_codegen_signature(op, inputs, outputs):
    args = ['runtime::XCProgramProto* program']
    for out in outputs:
        args.append('%s %s' % (out.c_codegen_type(), out.name))
    for inp in inputs:
        args.append('%s %s' % (inp.c_type(), inp.name))
    args = ', '.join(args)
    return 'void Add%sOp(%s)' % (op, args)


def gen_xcvm_codegen_h():
    lines = []
    for op in XC_ALL_OPS:
        signature = make_codegen_signature(op.name, op.inputs, op.outputs)
        lines.append(signature + ';')

    with open(args.output_dir + '/gen_xcvm_codegen.h', 'w') as f:
        f.write(r'''// Auto-generated by gen_xcvm.py

#pragma once

#include <compiler/xcvm/xcvm_value.h>
#include <runtime/xcvm.pb.h>

namespace chainer_compiler {
namespace xcvm {

''')
        f.writelines(codegen_util.format_code(lines))
        f.write(r'''
}  // namespace xcvm
}  // namespace chainer_compiler
''')


def gen_xcvm_codegen_cc():
    lines = []
    for op in XC_ALL_OPS:
        signature = make_codegen_signature(op.name, op.inputs, op.outputs)
        lines.append(signature + ' {')

        lines.append('XCInstructionProto* inst = program->add_instructions();')
        lines.append('inst->set_op(XCInstructionProto::%s);' % op.name)

        for inp in op.inputs:
            lines.append('{')
            lines.append('XCValueProto* input_proto = inst->add_inputs();')
            enum = inp.typ.replace('OPTIONAL_', '')
            lines.append('input_proto->set_type(XCValueProto::%s);' % enum)
            pfn = inp.proto_field_name()
            name = inp.name
            if inp.is_repeated():
                lines.append('for (auto v : %s) ' % name +
                             'input_proto->add_%s(v);' % pfn)
            else:
                lines.append('input_proto->set_%s(%s);' % (pfn, name))
            lines.append('}')

        for typ, name in op.outputs:
            if typ == ARRAY_LIST:
                lines.append('for (const XCVMValue& v : %s) v.AddOutput(inst);' % name)
            else:
                lines.append('%s.AddOutput(inst);' % name)

        lines.append('}')

    with open(args.output_dir + '/gen_xcvm_codegen.cc', 'w') as f:
        f.write(r'''// Auto-generated by gen_xcvm.py

#include <compiler/gen_xcvm_codegen.h>
#include <runtime/xcvm.pb.h>

namespace chainer_compiler {
namespace xcvm {

using runtime::XCInstructionProto;
using runtime::XCValueProto;

''')
        f.writelines(codegen_util.format_code(lines))
        f.write(r'''
}  // namespace xcvm
}  // namespace chainer_compiler
''')


if __name__ == '__main__':
    gen_xcvm_codegen_h()
    gen_xcvm_codegen_cc()
